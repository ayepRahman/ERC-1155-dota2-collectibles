Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ethers = tslib_1.__importStar(require("ethers"));
const utils_1 = require("./utils");
const utils = tslib_1.__importStar(require("./utils"));
// init test wallets from package.json mnemonic
const web3 = global.web3;
const { wallet: owner, provider: ownerProvider, signer: ownerSigner } = utils.createTestWallet(web3, 0);
const { wallet: receiver, provider: receiverProvider, signer: receiverSigner } = utils.createTestWallet(web3, 2);
const { wallet: receiver2, provider: receiver2Provider, signer: receiver2Signer } = utils.createTestWallet(web3, 3);
const { wallet: anyone, provider: anyoneProvider, signer: anyoneSigner } = utils.createTestWallet(web3, 4);
// TO DO
// Check over/under flow for both uin256 and uint16
// Modify existing ERC20 and basic token related tests
// Test the _updatetypesBalance operations
contract('Efficiency Comparison Tests', (accounts) => {
    const nTransfers = 30;
    const toTransfer = 10; // Amount to transfer per transfer
    const toMint = 15; // Amount to mint per transfer
    // Array of amount
    const IDArray = Array.apply(null, { length: nTransfers }).map(Number.call, Number);
    const amountArray = Array.apply(null, Array(nTransfers)).map(Number.prototype.valueOf, toTransfer);
    let erc721Contract;
    describe('ERC721 Tokens', () => {
        beforeEach(async () => {
            let abstract = await utils_1.AbstractContract.fromArtifactName('ERC721Mock');
            erc721Contract = await abstract.deploy(owner);
            for (let i = 0; i < nTransfers; i++) {
                await erc721Contract.functions.mockMint(owner.address, i);
            }
        });
        describe('Transferring ' + nTransfers + ' ERC721 tokens in different transaction calls', () => {
            it('', async () => {
                let sumGasCost = 0;
                for (let i = 0; i < nTransfers; i++) {
                    const tx = await erc721Contract.functions.transferFrom(owner.address, receiver.address, i);
                    const receipt = await tx.wait();
                    sumGasCost += receipt.gasUsed.toNumber();
                }
                console.log('Total gas cost  : ', sumGasCost);
                console.log('Per Tx Gas cost : ', sumGasCost / nTransfers);
            });
        });
        describe('Transferring ' + nTransfers + ' ERC721 tokens with wrapper contract', () => {
            it('', async () => {
                const data = ethers.utils.toUtf8Bytes('hello');
                // NOTE: typechain generates the wrong type for `bytes` type at this time
                // see https://github.com/ethereum-ts/TypeChain/issues/123
                // @ts-ignore
                const tx = await erc721Contract.functions.batchTransferFrom(owner.address, receiver.address, IDArray, data);
                const receipt = await tx.wait();
                console.log('Total gas cost  : ', receipt.gasUsed.toNumber());
                console.log('Per Tx Gas cost : ', receipt.gasUsed.toNumber() / nTransfers);
            });
        });
    });
    describe('ERC20 Tokens', () => {
        let tokenContracts;
        beforeEach(async () => {
            tokenContracts = [];
            let abstract = await utils_1.AbstractContract.fromArtifactName('ERC20Mock');
            for (let i = 0; i < nTransfers; i++) {
                const contract = await abstract.deploy(owner);
                const tx = contract.functions.mockMint(owner.address, toMint);
                await utils_1.expect(tx).to.be.fulfilled;
                tokenContracts.push(contract);
            }
        });
        describe('Transferring 30 ERC20 tokens in different transaction calls', () => {
            it('', async () => {
                let sumGasCost = 0;
                for (let i = 0; i < nTransfers; i++) {
                    const tx = await tokenContracts[i].functions.transfer(receiver.address, toTransfer);
                    const receipt = await tx.wait();
                    sumGasCost += receipt.gasUsed.toNumber();
                }
                console.log('Total gas cost  : ', sumGasCost);
                console.log('Per Tx Gas cost : ', sumGasCost / nTransfers);
            });
        });
        describe('Transferring ' + nTransfers + ' ERC20 tokens with a wrapper contract', () => {
            it('', async () => {
                let tokenAddresses = [];
                let abstract = await utils_1.AbstractContract.fromArtifactName('ERC20Mock');
                const metaToken = await abstract.deploy(owner);
                for (let i = 0; i < nTransfers; i++) {
                    const tx = tokenContracts[i].functions.mockMint(metaToken.address, toMint);
                    await utils_1.expect(tx).to.be.fulfilled;
                    tokenAddresses.push(tokenContracts[i].address);
                }
                // @ts-ignore
                const gas = await metaToken.estimate.batchTransfer(tokenAddresses, receiver2.address, amountArray);
                // console.log('estimate:', gas.toNumber())
                // TODO: review, ganache/ethers fails to estimate a proper gas amount and reverts
                // without the override below
                const overrides = {
                    gasLimit: gas.toNumber() + 1000
                };
                // @ts-ignore
                const tx = await metaToken.functions.batchTransfer(tokenAddresses, receiver2.address, amountArray, overrides);
                const receipt = await tx.wait();
                console.log('Total gas cost  : ', receipt.gasUsed.toNumber());
                console.log('Per Tx Gas cost : ', receipt.gasUsed.toNumber() / nTransfers);
            });
        });
    });
    describe('ERC1155 Tokens', () => {
        let erc1155NoBalancePackingContract;
        beforeEach(async () => {
            let abstract = await utils_1.AbstractContract.fromArtifactName('ERC1155MockNoBalancePacking');
            erc1155NoBalancePackingContract = await abstract.deploy(owner);
            for (let i = 0; i < nTransfers; i++) {
                await erc1155NoBalancePackingContract.functions.mockMint(owner.address, i, toMint);
            }
        });
        describe('Transferring ' + nTransfers + ' ERC1155 tokens via batch transfer', () => {
            it('', async () => {
                const tx = await erc1155NoBalancePackingContract.functions.batchTransferFrom(owner.address, receiver.address, IDArray, amountArray);
                const receipt = await tx.wait();
                console.log('Total gas cost  : ', receipt.gasUsed.toNumber());
                console.log('Per Tx Gas cost : ', receipt.gasUsed.toNumber() / nTransfers);
            });
        });
        context('ERC-1155 Tokens with Packed Balances', () => {
            let erc1155Contract;
            beforeEach(async () => {
                let abstract = await utils_1.AbstractContract.fromArtifactName('ERC1155Mock');
                erc1155Contract = await abstract.deploy(owner);
                for (let i = 0; i < nTransfers; i++) {
                    await erc1155Contract.functions.mockMint(owner.address, i, toMint);
                }
            });
            describe('Transferring ' + nTransfers + ' ERC1155 tokens with packed balance via safeBatchTra', () => {
                it('', async () => {
                    const tx = await erc1155Contract.functions.safeBatchTransferFrom(owner.address, receiver.address, IDArray, amountArray, []);
                    const receipt = await tx.wait();
                    console.log('Total gas cost  : ', receipt.gasUsed.toNumber());
                    console.log('Per Tx Gas cost : ', receipt.gasUsed.toNumber() / nTransfers);
                });
            });
        });
    });
});
//# sourceMappingURL=transfer.bench.js.map