Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ethers = tslib_1.__importStar(require("ethers"));
const signing_key_1 = require("ethers/utils/signing-key");
const utils_1 = require("ethers/utils");
exports.UNIT_ETH = ethers.utils.parseEther('1');
exports.HIGH_GAS_LIMIT = { gasLimit: 6e9 };
// createTestWallet creates a new wallet
exports.createTestWallet = (web3, addressIndex = 0) => {
    const provider = new Web3DebugProvider(web3.currentProvider);
    const wallet = ethers.Wallet
        .fromMnemonic(process.env.npm_package_config_mnemonic, `m/44'/60'/0'/0/${addressIndex}`)
        .connect(provider);
    const signer = provider.getSigner(addressIndex);
    return { wallet, provider, signer };
};
// Check if tx was Reverted with specified message
function RevertError(errorMessage) {
    let prefix = 'VM Exception while processing transaction: revert ';
    return prefix + errorMessage;
}
exports.RevertError = RevertError;
// Take a message, hash it and sign it with ETH_SIGN SignatureType
async function ethSign(wallet, message) {
    let hash = ethers.utils.keccak256(message);
    let hashArray = ethers.utils.arrayify(hash);
    let ethsigNoType = await wallet.signMessage(hashArray);
    return ethsigNoType + '02';
}
exports.ethSign = ethSign;
exports.GasReceiptType = `tuple(
    uint256 gasLimit,
    uint256 baseGas,
    uint256 gasPrice,
    uint256 feeToken,
    address feeRecipient
  )`;
// Will encode a gasReceipt
function encodeGasReceipt(g) {
    return utils_1.defaultAbiCoder.encode([exports.GasReceiptType], [g]);
}
exports.encodeGasReceipt = encodeGasReceipt;
// Encode data that is passed to safeTransferFrom() for metaTransfers
async function encodeMetaTransferFromData(s, gasReceipt) {
    /** Three encoding scenario
     *  1. Gas receipt and transfer data:
     *   txData: ( '0xebc71fa5', signature,  gasReceipt, transferData)
     *
     *  2. Gas receipt without transfer data:
     *   txData: ('0xebc71fa5', signature,  gasReceipt)
     *
     *  3. No gasReceipt with transferData
     *   txData: ('0x3fed7708', signature, transferData)
     *
     *  4. No gasReceipt without transferData
     *   txData: ('0x3fed7708', signature)
     */
    let sigData; // Data to sign
    let metaTag; // meta transaction tag
    let txDataTypes; // Types of data to encode
    let sig; // Signature
    // Type of data to sign (Transfer data and gas receipt is added after)
    const sigArgTypes = [
        'address',
        'address',
        'address',
        'uint256',
        'uint256',
        'uint256',
    ];
    let signer = await s.signerWallet.getAddress();
    // Packed encoding of transfer signature message
    sigData = ethers.utils.solidityPack(sigArgTypes, [
        s.contractAddress,
        signer,
        s.receiver,
        s.id,
        s.amount,
        s.nonce,
    ]);
    txDataTypes = ['bytes4', 'bytes', 'bytes']; // (metaTag, sig, (gasReceipt, transferData))
    // When gas receipt is included
    if (gasReceipt && gasReceipt !== null) {
        metaTag = '0xebc71fa5';
        // 1. 
        if (s.transferData !== null) {
            let gasAndTransferData = utils_1.defaultAbiCoder.encode([exports.GasReceiptType, 'bytes'], [gasReceipt, s.transferData]);
            sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, gasAndTransferData]);
            sig = await ethSign(s.signerWallet, sigData);
            return utils_1.defaultAbiCoder.encode(txDataTypes, [metaTag, sig, gasAndTransferData]);
            // 2.
        }
        else {
            let gasAndTransferData = utils_1.defaultAbiCoder.encode([exports.GasReceiptType, 'bytes'], [gasReceipt, utils_1.toUtf8Bytes('')]);
            sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, gasAndTransferData]);
            sig = await ethSign(s.signerWallet, sigData);
            return utils_1.defaultAbiCoder.encode(txDataTypes, [metaTag, sig, gasAndTransferData]);
        }
    }
    else {
        metaTag = '0x3fed7708';
        // 3.
        if (s.transferData !== null) {
            sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, s.transferData]);
            sig = await ethSign(s.signerWallet, sigData);
            return utils_1.defaultAbiCoder.encode(txDataTypes, [metaTag, sig, s.transferData]);
            // 4.
        }
        else {
            let emptyTransferData = utils_1.defaultAbiCoder.encode(['bytes'], [utils_1.toUtf8Bytes('')]);
            sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, emptyTransferData]);
            sig = await ethSign(s.signerWallet, sigData);
            return utils_1.defaultAbiCoder.encode(txDataTypes, [metaTag, sig, emptyTransferData]);
        }
    }
}
exports.encodeMetaTransferFromData = encodeMetaTransferFromData;
// Encode data that is passed to safeTransferFrom() for metaTransfers
async function encodeMetaBatchTransferFromData(s, gasReceipt) {
    /** Three encoding scenario
     *  1. Gas receipt and transfer data:
     *   txData: ( '0xebc71fa5', signature,  gasReceipt, transferData)
     *
     *  2. Gas receipt without transfer data:
     *   txData: ('0xebc71fa5', signature,  gasReceipt)
     *
     *  3. No gasReceipt with transferData
     *   txData: ('0x3fed7708', signature, transferData)
     *
     *  4. No gasReceipt without transferData
     *   txData: ('0x3fed7708', signature)
     */
    let sigData; // Data to sign
    let metaTag; // meta transaction tag
    let txDataTypes; // Types of data to encode
    let sig; // Signature
    // Type of data to sign (Transfer data and gas receipt is added after)
    const sigArgTypes = [
        'address',
        'address',
        'address',
        'uint256[]',
        'uint256[]',
        'uint256',
    ];
    let signer = await s.signerWallet.getAddress();
    // Packed encoding of transfer signature message
    sigData = ethers.utils.solidityPack(sigArgTypes, [
        s.contractAddress,
        signer,
        s.receiver,
        s.ids,
        s.amounts,
        s.nonce,
    ]);
    txDataTypes = ['bytes4', 'bytes', 'bytes']; // (metaTag, sig, (gasReceipt, transferData))
    // When gas receipt is included
    if (gasReceipt && gasReceipt !== null) {
        metaTag = '0xebc71fa5';
        // 1. 
        if (s.transferData !== null) {
            let gasAndTransferData = utils_1.defaultAbiCoder.encode([exports.GasReceiptType, 'bytes'], [gasReceipt, s.transferData]);
            sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, gasAndTransferData]);
            sig = await ethSign(s.signerWallet, sigData);
            return utils_1.defaultAbiCoder.encode(txDataTypes, [metaTag, sig, gasAndTransferData]);
            // 2.
        }
        else {
            let gasAndTransferData = utils_1.defaultAbiCoder.encode([exports.GasReceiptType, 'bytes'], [gasReceipt, utils_1.toUtf8Bytes('')]);
            sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, gasAndTransferData]);
            sig = await ethSign(s.signerWallet, sigData);
            return utils_1.defaultAbiCoder.encode(txDataTypes, [metaTag, sig, gasAndTransferData]);
        }
    }
    else {
        metaTag = '0x3fed7708';
        // 3.
        if (s.transferData !== null) {
            sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, s.transferData]);
            sig = await ethSign(s.signerWallet, sigData);
            return utils_1.defaultAbiCoder.encode(txDataTypes, [metaTag, sig, s.transferData]);
            // 4.
        }
        else {
            let emptyTransferData = utils_1.defaultAbiCoder.encode(['bytes'], [utils_1.toUtf8Bytes('')]);
            sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, emptyTransferData]);
            sig = await ethSign(s.signerWallet, sigData);
            return utils_1.defaultAbiCoder.encode(txDataTypes, [metaTag, sig, emptyTransferData]);
        }
    }
}
exports.encodeMetaBatchTransferFromData = encodeMetaBatchTransferFromData;
// Encode data that is passed to safeTransferFrom() for metaTransfers
async function encodeMetaApprovalData(a, gasReceipt) {
    let sigData; // Data to sign
    let txDataTypes; // Types of data to encode
    let sig; // Signature
    // Type of data to sign (Transfer data and gas receipt is added after)
    const sigArgTypes = [
        'address',
        'address',
        'address',
        'bool',
        'uint256'
    ];
    // Get signer
    let signer = await a.signerWallet.getAddress();
    // Packed encoding of transfer signature message
    sigData = ethers.utils.solidityPack(sigArgTypes, [
        a.contractAddress,
        signer,
        a.operator,
        a.approved,
        a.nonce
    ]);
    // When gas receipt is included
    if (gasReceipt && gasReceipt !== null) {
        let gasData = utils_1.defaultAbiCoder.encode([exports.GasReceiptType], [gasReceipt]);
        sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, gasData]);
        sig = await ethSign(a.signerWallet, sigData);
        txDataTypes = ['bytes', 'bytes']; // (sig, (gasReceipt))
        return utils_1.defaultAbiCoder.encode(txDataTypes, [sig, gasData]);
    }
    else {
        txDataTypes = ['bytes', 'bytes']; // (sig, '')
        sigData = ethers.utils.solidityPack(['bytes', 'bytes'], [sigData, utils_1.toUtf8Bytes('')]);
        sig = await ethSign(a.signerWallet, sigData);
        return utils_1.defaultAbiCoder.encode(txDataTypes, [sig, utils_1.toUtf8Bytes('')]);
    }
}
exports.encodeMetaApprovalData = encodeMetaApprovalData;
// Take a message, hash it and sign it with EIP_712_SIG SignatureType
function eip712Sign(wallet, message) {
    let hash = ethers.utils.keccak256(message);
    let signerSigningKey = new signing_key_1.SigningKey(wallet.privateKey);
    let eip712sig = utils_1.joinSignature(signerSigningKey.signDigest(hash));
    return eip712sig + '01';
}
exports.eip712Sign = eip712Sign;
class Web3DebugProvider extends ethers.providers.JsonRpcProvider {
    constructor(web3Provider, network) {
        // HTTP has a host; IPC has a path.
        super(web3Provider.host || web3Provider.path || '', network);
        this.reqCounter = 0;
        this.reqLog = [];
        if (web3Provider) {
            if (web3Provider.sendAsync) {
                this._sendAsync = web3Provider.sendAsync.bind(web3Provider);
            }
            else if (web3Provider.send) {
                this._sendAsync = web3Provider.send.bind(web3Provider);
            }
        }
        if (!web3Provider || !this._sendAsync) {
            ethers.errors.throwError('invalid web3Provider', ethers.errors.INVALID_ARGUMENT, { arg: 'web3Provider', value: web3Provider });
        }
        ethers.utils.defineReadOnly(this, '_web3Provider', web3Provider);
    }
    send(method, params) {
        this.reqCounter++;
        return new Promise((resolve, reject) => {
            let request = {
                method: method,
                params: params,
                id: this.reqCounter,
                jsonrpc: '2.0'
            };
            this.reqLog.push(request);
            this._sendAsync(request, function (error, result) {
                if (error) {
                    reject(error);
                    return;
                }
                if (result.error) {
                    // @TODO: not any
                    let error = new Error(result.error.message);
                    error.code = result.error.code;
                    error.data = result.error.data;
                    reject(error);
                    return;
                }
                resolve(result.result);
            });
        });
    }
    getPastRequest(reverseIndex = 0) {
        if (this.reqLog.length === 0) {
            return { jsonrpc: '2.0', id: 0, method: null, params: null };
        }
        return this.reqLog[this.reqLog.length - reverseIndex - 1];
    }
}
exports.Web3DebugProvider = Web3DebugProvider;
//# sourceMappingURL=helpers.js.map